#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <locale.h>
#include <wchar.h> //Работа с широкими символами (Unicode).
#include "manacher.h"

#define MIN_LEN 2 // минимальная длина палиндрома

//Функция is_unique проверяет, является ли подстрока уникальной среди уже найденных палиндромов.
bool is_unique(const wchar_t *str, int start, int len, wchar_t **found, int count) { //const wchar_t *str Указатель на исходную широкую строку (Unicode), в которой ищутся палиндромы. int start Начальный индекс подстроки в str, которую нужно проверить на уникальность. int len Длина подстроки (палиндрома), которую нужно проверить. wchar_t **found Массив уже найденных уникальных палиндромов (каждый элемент — указатель на строку). int count Количество палиндромов в массиве found.
    for (int i = 0; i < count; i++) { //Перебираем все ранее найденные палиндромы (от 0 до count-1).
        if (wcsncmp(&str[start], found[i], len) == 0 && wcslen(found[i]) == len) //Сравнивает подстроку str[start ... start+len-1] с текущим палиндромом found[i]. и Проверяет, что длина found[i] равна len (чтобы избежать частичных совпадений).
            return false;
    }
    return true; //если палиндром уникален.
}

void find_and_print_palindromes(const char *input_utf8) { 
    setlocale(LC_ALL, ""); //устанавливает локаль для корректной работы с широкими символами (Unicode). LC_ALL - применяет настройки ко всем аспектам локали "" - означает "использовать локаль по умолчанию системы" Без этого кириллица может превратиться в "кракозябры".
 
    // Перевод UTF-8 строки в wide string
    size_t wlen = mbstowcs(NULL, input_utf8, 0); //mbstowcs(NULL, input_utf8, 0) — вычисляет длину широкой строки.NULL - указатель на буфер (NULL означает "только посчитать длину") input_utf8 - исходная строка в UTF-8 0 - максимальное количество символов для конвертации (0 означает "весь строку") Функция mbstowcs  используется для преобразования строки в многобайтовой кодировке (обычно UTF-8) в строку широких символов (Unicode). Это критически важно для корректной обработки не-ASCII символов, таких как кириллица, иероглифы и другие Unicode-символы.
    if (wlen == (size_t)-1) {
        fprintf(stderr, "Ошибка: не удалось преобразовать в широкую строку\n"); //stderr (Standard Error) — это стандартный поток вывода ошибок, определённый в стандартной библиотеке C (<stdio.h>).
        return;
    }

    wchar_t *s = malloc((wlen + 1) * sizeof(wchar_t)); //выделение под wide-строку Расчёт размера: wlen - количество символов (без нуль-терминатора) +1 - для завершающего L'\0' sizeof(wchar_t) - размер широкого символа (обычно 2 или 4 байта)
    if (!s) return; //Проверка выделения памяти
    mbstowcs(s, input_utf8, wlen + 1); //mbstowcs — это ключевая функция для преобразования многобайтовых строк (например, UTF-8) в широкие строки (wchar_t). Она используется для корректной обработки Unicode в C-программах.

    int *P = calloc(2 * wlen + 1, sizeof(int)); // P — массив для хранения длин палиндромов с центрами в каждой позиции.
    if (!P) {
        free(s);
        return;
    }

    int center = 0, right = 0; //center, right — границы текущего самого правого палиндрома.
    wchar_t **found = malloc(wlen * sizeof(wchar_t *)); //found — массив для хранения уникальных палиндромов.
    int found_count = 0; //found_count — количество найденных палиндромов.

    //Алгоритм Манакера реализация
    for (int i = 0; i < 2 * wlen + 1; i++) { //Строка "расширяется" вставкой виртуальных символов (например, #a#n#n#a#), чтобы обрабатывать чётные и нечётные палиндромы одинаково.
        int mirror = 2 * center - i;
        if (i < right)
            P[i] = (P[mirror] < right - i) ? P[mirror] : right - i; //Если i внутри текущего палиндрома (i < right), используем симметрию, чтобы избежать лишних проверок.
        // границы для расширения
        int a = i + (1 + P[i]); // P[i] содержит текущий известный радиус палиндрома для позиции i.
        int b = i - (1 + P[i]); // Мы пытаемся проверить символы за пределами уже известного палиндрома.

        while (a < 2 * wlen + 1 && b >= 0 && // Проверка границ массива Гарантирует, что мы не выходим за границы строки.
               ((a % 2 == 0 || b % 2 == 0) || s[a / 2] == s[b / 2])) { // Если хотя бы одна из позиций указывает на виртуальный символ # (чётный индекс), считаем, что символы "совпадают". || Сравниваем реальные символы в исходной строке (для нечётных индексов).
            if (a % 2 == 1 && b % 2 == 1 && s[a / 2] != s[b / 2]) break; // Если оба символа реальные (нечётные индексы) и не совпадают, прекращаем расширение.
            P[i]++; // Увеличиваем радиус палиндрома
            a++; // Сдвигаем правую границу вправо
            b--; // Сдвигаем левую границу влево
        }
        // Здесь обновляется текущий "центр" и правую границу самого правого палиндрома, который мы уже нашли. Если текущий палиндром (на позиции i с радиусом P[i]) выходит за пределы ранее известной правой границы (right), то мы обновляем center и right.
        if (i + P[i] > right) {
            center = i;
            right = i + P[i];
        }

        int len = P[i]; // получаем длину палиндрома в текущей позиции.
        if (len >= MIN_LEN) { // проверяем, что длина палиндрома не меньше минимальной требуемой
            int start = (i - len) / 2; // вычисляем начальную позицию палиндрома в исходной строке
            if (start + len <= wlen && is_unique(s, start, len, found, found_count)) { // Проверяем, что палиндром не выходит за границы строки и является уникальным (функция is_unique).
                wchar_t *pal = malloc((len + 1) * sizeof(wchar_t)); // Если условия выполнены, выделяем память под палиндром, копируем его туда, добавляем в массив найденных палиндромов (found) и выводим.
                wcsncpy(pal, &s[start], len); // Эта строка кода выполняет копирование подстроки из исходной широкосимвольной строки s в новую строку pal.
                pal[len] = L'\0'; // Добавляем нуль-терминатор в конец строки pal
                found[found_count++] = pal; //Добавляем найденный палиндром в массив found и увеличиваем счётчик found_count
                wprintf(L"Палиндром: %ls\n", pal);
            }
        }
    }

    for (int i = 0; i < found_count; i++)
        free(found[i]); //Освобождаем память, выделенную под каждый палиндром в массиве found

    free(found); // Освобождаем память, выделенную под сам массив found.
    free(P); // Освобождаем память, выделенную под массив длин палиндромов P
    free(s); 
}
