#include <stdio.h>

#define N_MAX 10  //Максимальный размер матрицы 10

//Функция для вычисления определителя матрицы N x N
float determinant(float matrix[N_MAX][N_MAX], int n) { //n - размер матрицы
    if (n == 1) 
        return matrix[0][0];

    if (n == 2)
        return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0];  //т.к размер матрицы 2, вычисляем определитель матрицы для 2х2, по формуле det=a*d-b*c, где a=11.b=21.c=12.d=22

    float det = 0;//переменная для хранения значения матрицы
    float submatrix[N_MAX][N_MAX];// обьявление двумерного массива submatrix для хранения подматриц,которые создаются при вычислении определителя матрицы nxn.Подматрица используется для рекурсивного вычисления определителя.При вычислении определителя матрицы nxn, необходимо исключить одну строку и текущий столбец(в нашем случае первую строку и текущий столбец в цикле) это и формирует подматрицу размером (n-1)x(n-1)

    for (int x = 0; x < n; x++) { //цикл for выполняется n раз. x используется в качестве индекса,представляющего текущий столбец, по которому выполнятеся разложение определителя. так цикл будет по очереди проходить каждый столбец матрицы. Что происходит внутри цикла? 1.в цикле создается подматрица для каждого столбца(исключение первой строки и текущего столбца) 2.Вычисление определителя для каждой из подматриц 3.Суммирование этих значений с цчетом знака(+ или -) для окончательного вычисления определителя оригинальной матрицы  
        int subi = 0;// subi используется как индекс для строк подматрицы,которую мы собираемся создать. Когда мы исключаем 1 строку и текущий столбец для формирования подматрицы, мы будем добавлять строки оригинальной матрицы в подматрицу.Переменная subi будетотслеживать текущую строку, которая будет добавлена в подматрицу. 
        for (int i = 1; i < n; i++) {// цикл по строкам оригинальной матрицы, начиная со второй строки индекс i=1 и до последней i<n
            int subj = 0;//subj используется как индекс для столбцов подматрицы.При создании подматрицы нам нужно исключить определённый столбец (определяемый переменной х в строке 16) subj будет отслеживать текущий столбецв подматрице, в которой будет добавлен элемент.
            for (int j = 0; j < n; j++) { //проход по всем столбцам текущей строки оригинальной матрицы, где n-размер матрицы
                if (j == x) //проверка совпадения столбца j с индексом стобца х, который нужно исключить для создания подматрицы.
                    continue;//если условие в 21 строке истино, то оставшийся цикл пропускается и начинается новая итерация
                submatrix[subi][subj] = matrix[i][j];//копируем значение элемента из оригинальной матрицы matrix в подматрицу submatrix 
                subj++;//+1 после копирования
            }
            subi++;//+1 после того,как все нужные элементы оригинальной матрицы были добавлены в подматрицу
        }
        det += (x % 2 == 0 ? 1 : -1) * matrix[0][x] * determinant(submatrix, n - 1);}//тернарный оператор,который определяет знак для кадого элемента в разложении определителя.x-чётное,вернёт знак 1(+) х-нечётное вернет знак -1(-).Это чередование знаков соотвествует правилу для разложения определителя по строке.   

    return det;//возвращает определитель матрицы
}

//Функция для замены столбца в матрице (копирует исходную матрицу с заменой столбца)
void replaceColumn(float matrix[N_MAX][N_MAX], float newColumn[N_MAX], float result[N_MAX][N_MAX], int column, int n) { //функция для замены столбца в матрице.matrix матрица размером nxn, который представляет исходную матрицу, в которой будет производиться замена столбца.newColomn это массив содержащий новые значения, которые будут использоваться для замены выбранного столбца в исходной матрице. result будет хранить результат замены. int colomn целое число,которое указывает, какой столбец в исходной матрице будет заменен. int n это целое число,указывающее количество строк и столбцов в матрице
    for (int i = 0; i < n; i++)//внутри данного цикла будет производиться копирование жлементов исходной матрицы matrix в матрицу result,заменяя выбранный столбец colomn значениями из newColomn.Цикл организован по строкам,чтобы на каждой строке выполнить операцию замены конктреного столбца.
        for (int j = 0; j < n; j++)
            result[i][j] = (j == column) ? newColumn[i] : matrix[i][j];--
}

//Функция для решения СЛАУ методом Крамера
void Cramer(float matrix[N_MAX][N_MAX], float results[N_MAX], int n) { //matrix двумерный массив, который представляет коэффиценты системы линейных уравнений. results это одномерный массив, представляющий столбец свободных членов системы уравнений длинна массива-N_MAX. int n это размер матрицы или количество уравнений и переменных в системе,что позволяет использовать функцию для любой матрицы до размера 10.
    float D = determinant(matrix, n);// вызыв фунции передавая ей исходную матрицу и её размер,результат является определителем
    if (D == 0) { //проверка на нулевой определитель
        printf("Система не имеет единственного решения.\n");
        return;
    }

    float x[N_MAX];//массив х предназначен для хранения значений переменных системы линейных уравнений, которые будут вычислены методом Крамера.Каждый элемент массива будет соответствовать одной из перемменных системы(например x[0] для x1 х[1] для х2 и тд)
    float tempMatrix[N_MAX][N_MAX];//объявление двумерного массива который будет использоваться для хранения копии исходной матрицы с заменёнными стобцами
    for (int i = 0; i < n; i++) {//цикл проходит по всем переменным системы.В каждой итерации функция будет заменять соответсвующий столбец в матрице matrix на столбец свободных членов results (используя tempMatrix) и вычислять определитель этой модифицированной матрицы.
        replaceColumn(matrix, results, tempMatrix, i, n);//Этот вызов создает матрицу tempMatrix,которая является копией matrix,но в которой i-й столбец заменён на столбец results.Это временная матрица будет использоваться для вычисления определителя
        x[i] = determinant(tempMatrix, n) / D;// формула Крамера для нахождения временнного определителя матрицы tempMatrix, где был заменён i-й столбец 
    }

//Вывод решения
    for (int i = 0; i < n; i++) { //нахождение количества переменных в системе 
        printf("x%d = %.2f\n", i + 1, x[i]); //вывод каждой переменной на экран
    }
}
int main() {
    int n;//хранение размера СЛУ(количества перемменных и уравнений)
    printf("Введите размер системы уравнений N (не более %d): ", N_MAX);//ввод размера СЛУ.%d будет заменён на N_MAX, указывая максимальный допустимый размер матрицы,установленный заранее
    scanf("%d", &n);

    if (n > N_MAX || n < 1) { //проверка на то, находится ли введеное число n в допустимом диапазоне
        printf("Неверный размер матрицы.\n");
        return 1;
    }

    float matrix[N_MAX][N_MAX];//массив,представляющйи матрицу коэффицентнов СЛУ.
    float results[N_MAX];//массив для хранения свободных членов системы уравнений

    printf("Введите коэффициенты матрицы %dx%d:\n", n, n);//ввод коэффицентов для квадратной матрицы
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++) {
            printf("matrix[%d][%d] = ", i + 1, j + 1);
            scanf("%f", &matrix[i][j]);
        }

    printf("Введите свободные члены:\n");
    for (int i = 0; i < n; i++) {
        printf("results[%d] = ", i + 1);//ввод значения для текущего свободного члена.%d будет заменен на i+1, чтобы пользователь видел номера,начиная с 1.
        scanf("%f", &results[i]);
    }

    Cramer(matrix, results, n);

    return 0;
}
