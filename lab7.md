Оценка 3:
![code_20250506_165428_via_10015_io](https://github.com/user-attachments/assets/db49ffc3-79e9-4df6-af01-28b00954c985)
Отчет о проделанной работе
Цель работы
Изучение и практическое применение многопоточного программирования на языке C с использованием библиотеки pthread.h. В ходе работы были реализованы различные сценарии создания, управления и завершения потоков, а также применены механизмы синхронизации и обработки завершения потоков.

Задание 1: Создание потока
Цель: Научиться создавать поток с помощью функции pthread_create().
Реализация:

В функции child_task() дочерний поток выводит 5 строк текста.

Родительский поток также выводит 5 строк текста параллельно с дочерним.
Вывод: Оба потока работают асинхронно, что подтверждает корректное создание и запуск потока.

Задание 2: Ожидание потока
Цель: Изучить использование функции pthread_join() для ожидания завершения дочернего потока.
Реализация:

Родительский поток ожидает завершения дочернего с помощью pthread_join(), после чего выводит свои строки.
Вывод: Ожидание потока гарантирует порядок выполнения: сначала дочерний поток, затем родительский.

Задание 3: Передача параметров в поток
Цель: Научиться передавать параметры в функцию потока.
Реализация:

Создано 4 потока, каждый из которых получает массив строк и выводит их.

Для каждого потока передается уникальный набор строк.
Вывод: Потоки успешно обрабатывают переданные параметры, демонстрируя возможность индивидуальной настройки задач.

Задание 4: Принудительное завершение потока
Цель: Изучить механизм принудительного завершения потоков с помощью pthread_cancel().
Реализация:

Потоки выводят строки с задержкой в 1 секунду.

Через 2 секунды родительский поток отменяет все дочерние потоки.
Вывод: Потоки могут быть прерваны до завершения их работы, что подтверждает работу pthread_cancel().

Задание 5: Обработка завершения потока
Цель: Научиться корректно обрабатывать завершение потока с использованием pthread_cleanup_push().
Реализация:

Добавлен обработчик cleanup(), который вызывается при отмене потока.

Потоки выводят сообщение о корректном завершении даже при принудительной отмене.
Вывод: Использование pthread_cleanup_push() позволяет выполнить необходимые действия перед завершением потока.

Задание 6: Реализация Sleepsort
Цель: Реализовать алгоритм сортировки Sleepsort, использующий задержки в потоках.
Реализация:

Для каждого элемента массива создается поток, который "засыпает" на время, пропорциональное значению элемента.

После пробуждения поток выводит значение элемента.
Вывод: Алгоритм работает корректно для небольших массивов, демонстрируя нестандартный подход к сортировке.

Заключение
В ходе работы были освоены основные механизмы работы с потоками в C: создание, ожидание, передача параметров, принудительное завершение и обработка завершения. Также был реализован нестандартный алгоритм сортировки, демонстрирующий гибкость многопоточного программирования.
Итог: Программа успешно выполняет все поставленные задачи, подтверждая понимание принципов многопоточности

оценка 4:

![code_20250506_165331_via_10015_io](https://github.com/user-attachments/assets/7ee91cfd-0d01-4c1b-8c3f-15192a0a4538)


график:
![image](https://github.com/user-attachments/assets/ea8b0ae7-e4d3-45c7-884f-82f73ddb4717)

Общий тренд:
С увеличением размера матрицы время выполнения операции растёт нелинейно (вероятно, экспоненциально), что ожидаемо для алгоритма перемножения матриц с сложностью O(N³).
Влияние числа потоков:
Малые матрицы (например, N < 500):
Увеличение числа потоков не даёт значительного ускорения или даже может замедлять выполнение из-за накладных расходов на управление потоками.
Средние и большие матрицы (N > 1000):
Чем больше потоков (до определённого предела, например 16-32), тем заметнее ускорение. Например, для N=2000 время с 1 потоком может быть в несколько раз выше, чем с 16 потоками.
После определённого числа потоков (например, 64-128) прирост скорости замедляется или останавливается из-за ограничений процессора (например, числа физических ядер) и накладных расходов.
Оптимальное число потоков:
Для больших матриц оптимальное число потоков обычно близко к числу физических ядер процессора. Например, если CPU имеет 16 ядер, то дальнейшее увеличение потоков (32, 64) может не давать улучшения.
Выводы:
Параллелизация эффективна для больших матриц, но требует баланса между числом потоков и аппаратными возможностями.
Для малых задач многопоточность может быть избыточной.
График демонстрирует типичный профиль производительности для параллельных вычислений: ускорение при увеличении потоков до определённого предела с последующим насыщением.

оценка 5:

![code_20250506_165253_via_10015_io](https://github.com/user-attachments/assets/46f68a1a-1b72-4ccf-b051-59f27a8f015b)

