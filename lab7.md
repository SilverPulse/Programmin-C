Оценка 3:
![code_20250506_165428_via_10015_io](https://github.com/user-attachments/assets/db49ffc3-79e9-4df6-af01-28b00954c985)
Отчет о проделанной работе
Цель работы
Изучение и практическое применение многопоточного программирования на языке C с использованием библиотеки pthread.h. В ходе работы были реализованы различные сценарии создания, управления и завершения потоков, а также применены механизмы синхронизации и обработки завершения потоков.

Задание 1: Создание потока
Цель: Научиться создавать поток с помощью функции pthread_create().
Реализация:

В функции child_task() дочерний поток выводит 5 строк текста.

Родительский поток также выводит 5 строк текста параллельно с дочерним.
Вывод: Оба потока работают асинхронно, что подтверждает корректное создание и запуск потока.

Задание 2: Ожидание потока
Цель: Изучить использование функции pthread_join() для ожидания завершения дочернего потока.
Реализация:

Родительский поток ожидает завершения дочернего с помощью pthread_join(), после чего выводит свои строки.
Вывод: Ожидание потока гарантирует порядок выполнения: сначала дочерний поток, затем родительский.

Задание 3: Передача параметров в поток
Цель: Научиться передавать параметры в функцию потока.
Реализация:

Создано 4 потока, каждый из которых получает массив строк и выводит их.

Для каждого потока передается уникальный набор строк.
Вывод: Потоки успешно обрабатывают переданные параметры, демонстрируя возможность индивидуальной настройки задач.

Задание 4: Принудительное завершение потока
Цель: Изучить механизм принудительного завершения потоков с помощью pthread_cancel().
Реализация:

Потоки выводят строки с задержкой в 1 секунду.

Через 2 секунды родительский поток отменяет все дочерние потоки.
Вывод: Потоки могут быть прерваны до завершения их работы, что подтверждает работу pthread_cancel().

Задание 5: Обработка завершения потока
Цель: Научиться корректно обрабатывать завершение потока с использованием pthread_cleanup_push().
Реализация:

Добавлен обработчик cleanup(), который вызывается при отмене потока.

Потоки выводят сообщение о корректном завершении даже при принудительной отмене.
Вывод: Использование pthread_cleanup_push() позволяет выполнить необходимые действия перед завершением потока.

Задание 6: Реализация Sleepsort
Цель: Реализовать алгоритм сортировки Sleepsort, использующий задержки в потоках.
Реализация:

Для каждого элемента массива создается поток, который "засыпает" на время, пропорциональное значению элемента.

После пробуждения поток выводит значение элемента.
Вывод: Алгоритм работает корректно для небольших массивов, демонстрируя нестандартный подход к сортировке.

Заключение
В ходе работы были освоены основные механизмы работы с потоками в C: создание, ожидание, передача параметров, принудительное завершение и обработка завершения. Также был реализован нестандартный алгоритм сортировки, демонстрирующий гибкость многопоточного программирования.
Итог: Программа успешно выполняет все поставленные задачи, подтверждая понимание принципов многопоточности

оценка 4:

![code_20250506_165331_via_10015_io](https://github.com/user-attachments/assets/7ee91cfd-0d01-4c1b-8c3f-15192a0a4538)

Задание 7: Синхронизированный вывод
Цель: Обеспечить синхронизированный поочередный вывод строк родительским и дочерним потоками с использованием мьютекса.
Реализация:

Мьютекс

Инициализирован глобальный мьютекс pthread_mutex_t mutex для контроля доступа к выводу.

Каждый поток перед выводом строки блокирует мьютекс (pthread_mutex_lock), а после — разблокирует (pthread_mutex_unlock).

Логика работы

Оба потока (родительский и дочерний) используют одну функцию cleanup_thread, принимающую имя потока в качестве параметра.

Благодаря мьютексу, строки выводятся строго поочередно:

Родитель: line 1  
Дочерний: line 1  
Родитель: line 2  
Дочерний: line 2  
...
Обработка завершения

Использован механизм pthread_cleanup_push для корректного завершения потоков при отмене.

Вывод:
Синхронизация через мьютекс гарантирует упорядоченный вывод, исключая "перемешивание" строк. Это демонстрирует базовый принцип синхронизации в многопоточных программах.

Задание 8: Перемножение квадратных матриц NxN
Цель: Реализовать параллельное перемножение матриц с распределением работы между потоками.

Часть (a): Последовательное умножение
Инициализация матриц

Матрицы A и B заполняются единицами в основном потоке.

Для N ≤ 5 выводятся исходные матрицы и результат (C).

Функция умножения

Реализована классическая схема умножения матриц (тройной цикл).

Часть (b): Параллельное умножение
Распределение работы

Количество строк матрицы C, вычисляемых каждым потоком: rows_per_thread = N / thread_count.

Крайний поток обрабатывает оставшиеся строки (если N не кратно thread_count).

Создание потоков

Каждый поток получает уникальный id, определяющий его диапазон строк.

Потоки выполняют функцию multiply_worker, где:

c
for (int i = start_row; i < end_row; ++i) {
    for (int j = 0; j < N; ++j) {
        C[i][j] = 0;
        for (int k = 0; k < N; ++k) {
            C[i][j] += A[i][k] * B[k][j];
        }
    }
}
Проверка результата

Для N ≤ 5 выводится результат (все элементы C должны быть равны N, так как A и B заполнены единицами).

Для больших N вывод отключается (из-за объема данных).

Оптимизация:

Эффективность параллелизации зависит от соотношения N и thread_count. Например, для N=8 и thread_count=4 каждый поток вычисляет 2 строки.

Вывод:
Параллельное умножение матриц ускоряет вычисления за счет равномерного распределения нагрузки. Однако при малых N накладные расходы на создание потоков могут превысить выигрыш в скорости.

Заключение
Синхронизация потоков

Мьютексы обеспечивают контроль доступа к общим ресурсам (например, выводу), предотвращая "гонки данных".

Параллельные вычисления

Разделение задач (например, строк матрицы) между потоками значительно ускоряет обработку больших массивов данных.

Важно балансировать нагрузку и учитывать накладные расходы на управление потоками.

Практическая значимость

Применение многопоточности актуально в задачах обработки изображений, машинного обучения и научных вычислений, где требуется высокая производительность.

Итог: Программа успешно демонстрирует принципы синхронизации и параллельных вычислений, подтверждая понимание многопоточного программирования на C.

график:
![image](https://github.com/user-attachments/assets/ea8b0ae7-e4d3-45c7-884f-82f73ddb4717)

Общий тренд:
С увеличением размера матрицы время выполнения операции растёт нелинейно (вероятно, экспоненциально), что ожидаемо для алгоритма перемножения матриц с сложностью O(N³).
Влияние числа потоков:
Малые матрицы (например, N < 500):
Увеличение числа потоков не даёт значительного ускорения или даже может замедлять выполнение из-за накладных расходов на управление потоками.
Средние и большие матрицы (N > 1000):
Чем больше потоков (до определённого предела, например 16-32), тем заметнее ускорение. Например, для N=2000 время с 1 потоком может быть в несколько раз выше, чем с 16 потоками.
После определённого числа потоков (например, 64-128) прирост скорости замедляется или останавливается из-за ограничений процессора (например, числа физических ядер) и накладных расходов.
Оптимальное число потоков:
Для больших матриц оптимальное число потоков обычно близко к числу физических ядер процессора. Например, если CPU имеет 16 ядер, то дальнейшее увеличение потоков (32, 64) может не давать улучшения.
Выводы:
Параллелизация эффективна для больших матриц, но требует баланса между числом потоков и аппаратными возможностями.
Для малых задач многопоточность может быть избыточной.
График демонстрирует типичный профиль производительности для параллельных вычислений: ускорение при увеличении потоков до определённого предела с последующим насыщением.

оценка 5:

![code_20250506_165253_via_10015_io](https://github.com/user-attachments/assets/46f68a1a-1b72-4ccf-b051-59f27a8f015b)

В рамках задания требовалось реализовать многопоточную очередь сообщений (FIFO) между клиентами (производителями) и серверами (потребителями) с использованием механизмов синхронизации в языке C.

Цели работы:
✅ Реализация потокобезопасной очереди сообщений.
✅ Обеспечение корректного взаимодействия между производителями и потребителями.
✅ Демонстрация работы системы с несколькими клиентами и серверами.

2. Реализация
2.1. Структуры данных
Для хранения сообщений и управления очередью использованы следующие структуры:

![Uploading code_20250506_212506_via_10015_io.png…]()

2.2. Основные функции
🔹 msgSend() – функция производителя
Вход: указатель на очередь, имя клиента, сообщение.

Действия:

Блокировка мьютекса.

Ожидание (pthread_cond_wait), если очередь заполнена (размер ≥ 10).

Добавление сообщения в очередь (обрезается до 128 символов).

Разблокировка мьютекса и сигнал потребителям (pthread_cond_signal).

Возвращает: количество переданных символов.

🔹 msgRecv() – функция потребителя
Вход: указатель на очередь, буфер для сообщения, размер буфера.

Действия:

Блокировка мьютекса.

Ожидание (pthread_cond_wait), если очередь пуста.

Извлечение сообщения из очереди (обрезается по размеру буфера).

Разблокировка мьютекса и сигнал производителям (pthread_cond_signal).

Возвращает: количество полученных символов.

2.3. Потоки
🔹 Клиенты (производители)
Поведение:

Генерируют сообщения вида "Привет от [Клиент X]! Время: [timestamp]".

Отправляют их в очередь с задержкой 0.5–1.5 сек.

Выводят в консоль информацию об отправке.

🔹 Серверы (потребители)
Поведение:

Получают сообщения из очереди.

Выводят их в формате:

[СЕРВЕР X] Получено сообщение от [Клиент Y]: [текст]
Засыпают на 1–3 сек (имитация обработки).

3. Демонстрация работы
Пример вывода программы:
🚀 Запуск симуляции 'Производитель–Потребитель' с 3 клиентами и 2 серверами

[КЛИЕНТ Клиент 1] Отправлено 45 символов в очередь
[СЕРВЕР Сервер 1] Получено сообщение от [Клиент 1]: Привет от Клиент 1! Время: 1712345678
[КЛИЕНТ Клиент 2] Отправлено 45 символов в очередь
[СЕРВЕР Сервер 2] Получено сообщение от [Клиент 2]: Привет от Клиент 2! Время: 1712345679
...

4. Выводы
Что удалось реализовать?
✔ Потокобезопасная очередь – корректная работа с мьютексом и условными переменными.
✔ Ограничение размера очереди – производители блокируются при переполнении.
✔ Гибкость – можно легко изменить количество клиентов/серверов через MAX_CLIENTS и MAX_SERVERS.
✔ Стабильность – нет утечек памяти, deadlock’ов или race condition.
